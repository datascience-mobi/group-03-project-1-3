---
title: 'Project 3: Ovarian Cancer'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Contents
1. Overview Ovarian Cancer
2. Data Cleanup
3. Driver Mutations
4. co-existing Mutations
5. Synthetic Lethality Interactions
6. Linear Regression
7. Summary of Results
8. Conclusion

## 1. Overview Ovarian Cancer

### 1.1 General facts

Ovarian cancer is the one of the leading cancer death causes in women. One of 71 women will be diagnosed with this disease at some point during her lifetime. When treated in early stages, OC has relatively high survival rates. However, symptomes mostly start to develop when the tumour has already progressed to advanced stages, which is why the overall 5-year survival rate for OC lies under 50%.

Ovarian cancer is a very heterogenous disease and mostly represented by epithelial tumours. There are four main subtypes: serous, endometrioid, mucinous and clear cell. Furthermore, tumours can be classified dependent on their state of differentiation. Low grade (LG) Ovarian cancer is well differentiated and therefore not invasive; high grade (HG) tumours are often aggressive and frequently metastasize.

Standard therapy approaches include surgery and chemotherapy with DNA-damaging agents. Personalized immunotherapeutic approaches often target special features of cancer cell genome and proteome such as over-expressed surface receptors.

### 1.2 Common mutations in OC (literature)

Literature on Ovarian cancer states that the most common mutations are found in the DNA repair-related genes BRCA1 and BRCA2. Abnormalities in other DNA and mismatch repair genes have been found too, as well as TP53, which is also known as "guardian of the genome". According to Testa et al., TP53 accounts for most mutations found in high grade serous Ovarian cancer.
It will be our task to verify this information and to gain insight on potential driver mutations in Ovarian cancer.

## 2. Data Cleanup

At first we download the dataset and load it into R-Studio
```{r}
allDepMapData <- readRDS("~/GitHub/project-01-group-03/DepMap19Q1_allData.RDS")
```

In order to get a better

```{r}
copynumber = allDepMapData[["copynumber"]]
mutation = allDepMapData[["mutation"]]
kd.ceres = allDepMapData[["kd.ceres"]]
kd.prob = allDepMapData[["kd.prob"]]
annotation = allDepMapData[["annotation"]]
expression = allDepMapData[["expression"]]

```
extract all cell lines that have ovarian cancer as primary disease. 
```{r}
annotation = annotation[which(annotation$Primary.Disease == "Ovarian Cancer"), ] # The annotation matrix now only consists of Ovarian Cancer cell lines
ID = annotation$DepMap_ID # DepMap_ID is the column name for the Ovarian Cancer cell lines
expression = expression[ , which(colnames(expression) %in% ID)] # Extract the expression column from ID and re-define the data frame called expression. Do the same for the columns copynumber, kd.ceres and kd.prob. (Stimmt das?)
copynumber = copynumber [ , which(colnames(copynumber) %in% ID)]
kd.ceres = kd.ceres [ , which(colnames(kd.ceres) %in% ID)]
kd.prob = kd.prob [ , which(colnames(kd.prob) %in% ID)]
mutation = mutation [ ID]
```

For further work with the annotation matrix it makes it a lot easier to rename the rows with the names of the cell lines. So far the rownames seem to be random numbers we can not use. In the column "DEPMap_ID" we can find the name of the actual cell lines.

```{r}
rownames(annotation) = annotation$DepMap_ID
```

Further we remove columns of the annotation matrix we dont need and unnecessary objects as well.

```{r}
# removing unecessary columns
annotation = annotation[, -which(colnames(annotation) %in% c("DepMap_ID", "Aliases", "Primary.Disease", "Gender", "Source"))]

#removing the main data, because we already extracted the OC Data
rm(allDepMapData)

```

Many functions don't work with NA values. That's why we check the matrices for NA values

```{r}
#summary(copynumber) hier m?ssen wirs hinkriegen dass er den output net reinhaut


NAV = apply(copynumber, 1, function(x) {sum(is.na(x))}) 
copynumber = copynumber[-which(NAV > 0), ]  

NAV = apply(expression, 1, function(x) {sum(is.na(x))}) 
expression = expression[-which(NAV > 0), ]  
 
NAV = apply(kd.ceres, 1, function(x) {sum(is.na(x))}) 
kd.ceres = kd.ceres[-which(NAV > 0), ]

NAV = apply(kd.prob, 1, function(x) {sum(is.na(x))}) 
kd.prob = kd.prob[-which(NAV > 0), ]
```

### Install packages
download the needed packages
```{r}
install.packages("reshape")
install.packages("ggplot2")
```
install the packages
```{r}
library(reshape)
library(ggplot2)
```

## 3. Driver Mutations


Fuse mutation lists to one matrix
```{r}
mutation.all = as.data.frame(rbindlist(mutation))
```

Our analyses just need the information in certain columns of our data frame, for example gene name and location (chromosome), cell line, the kind of mutation (missense, frame shift, etc.). Thus, we extract these columns and put them in the data frame "mutation.all".
```{r}
 mutation.all = mutation.all[, which(colnames(mutation.all) %in% c("Hugo_Symbol", "DepMap_ID", "Variant_Classification", "Variant_annotation", "isTCGAhotspot", "Chromosome", "isDeleterious"))]
```
There are different types of mutations. Some of them are silent, which means that the amino acid sequence is not altered and the protein structure is not affected. Other mutations lead to an amino acid exchange, but do not provoke dramatic conformational changes in the encoded protein. Whether or not a mutation has an impact on protein function is noted in the column "isDeleterious". We want to extract all mutations that are TRUE for isDeleterious, since these might have something to do with cancer cell development.
```{r}
mutation.all = mutation.all[which(mutation.all$isDeleterious == "TRUE"), ] # only include rows (=genes) that have deleterious mutations in data frame "mutation.all"
```
Order matrix alphabetically

```{r}
mutation.all <- mutation.all[order(mutation.all$Hugo_Symbol),]

```

Find most frequently mutated genes by summing up all "mutation events" found in all cell lines. To do this, the names of the genes were converted to factors.
```{r}
mutation.all$Hugo_Symbol = factor(mutation.all$Hugo_Symbol)

summary(mutation.all$Hugo_Symbol)

```
Plot all mutations to see most frequently mutated genes
```{r}
plot(mutation.all$Hugo_Symbol)
```


The most common mutation is found in ARID1A (16 times). Surprisingly, BRCA1 and BRCA2 are only mutated twice and once, respectively.

Problem: Many mutations occur several times in one cell line, but in different DNA loci. If we want to identify the most frequent mutations among all cell lines, these duplicates should not be included. We want to extract mutations that occur frequently in different cell lines. Therefore, we use the "duplicated" function from the dplyr package and define a new data frame called new_uniq that only contains one mutation of a gene per cell line for simplicity (since the type of mutation is not relevant here).

```{r}
duplicates <- which(duplicated(mutation.all[c('Hugo_Symbol', 'DepMap_ID')]), ) #find all identical combinations of mutated gene and cell line
duplicates # show all genes that are duplicated
new_uniq <- mutation.all[!duplicated(mutation.all[c('Hugo_Symbol', 'DepMap_ID')]),] #do not include duplicates in data frame new_uniq
summary(new_uniq)

```
As we can see, ARID1A is only the second most common mutation after TP53, which is mutated in 12 of 34 different cell lines. The most common mutations among our cell lines are thought to be our driver mutations. We will be conducting further analyses with these genes.

For a better overview, we solely plot genes that are mutated more than 4 times in total. Further analyses will focus on these designated driver mutations.

```{r}
DriverMutation <- as.data.frame(table(new_uniq$Hugo_Symbol)) # Create a new data frame that contains the mutated genes (but just once per cell line, as definded in new_uniq)
DriverMutation = DriverMutation[which(DriverMutation$Freq > 4), ] # extract all mutations that occur more than 4 times among our cell lines in total
DriverMutation <- DriverMutation[order(DriverMutation$Freq, decreasing = TRUE),] # order the genes in the data frame according to their frequency
barplot(DriverMutation$Freq, names.arg = DriverMutation$Var1, xlab="mutated Gene", las = 1, horiz=FALSE, cex.axis = 1,2, col = "lightblue", main = "mutations present in more than four cell lines", ylab = "frequency") # create a barplot of the most frequent mutations, displaying their occurence


```



## 4. Co-existing Mutations

Here, we want to investigate whether there are certain mutations that often occur together and are therefore possibly linked to each other in their genesis. The goal will be to create a symmetrical matrix whose columns AND rows are our genes; the cells' content will be the counts of how often two corresponding genes turn up in the same cell line together. Next, maximum values can be extracted and tested for significance.

To get a short overview about how many co existing mutations are common in the data we perform a tree diagram that clusters the Drivermutations


```{r}
#creating a new matrix containing every cell line that has at least one of our 7 Drivermutations

dm <- new_uniq[which(new_uniq$Hugo_Symbol %in% DriverMutation$Var1), ]

#and delete unnecesary columns
dm = dm[, -which(colnames(dm) %in% c("Chromosome", "isDeleterious", "Variant_annotation"))]

#lets check out how many Drivermutations are common in the cell lines
table(dm$DepMap_ID)

#to get acces to the single cell lines we have to create single matrices for every Drivermutation

dmTP53 = dm[which(dm$Hugo_Symbol == "TP53"), ]
dmARID1A = dm[which(dm$Hugo_Symbol == "ARID1A"), ]
dmATM = dm[which(dm$Hugo_Symbol == "ATM"), ]
dmBAI1 = dm[which(dm$Hugo_Symbol == "BAI1"), ]
dmPTPRF = dm[which(dm$Hugo_Symbol == "PTPRF"), ]
dmSYNE1 = dm[which(dm$Hugo_Symbol == "SYNE1"), ]
dmTHBS3 = dm[which(dm$Hugo_Symbol == "THBS3"), ]


#now we add new colums to the annotation matrix containing information about which cell line contains which Drivermutation
annotation$has_TP53 <- ifelse(rownames(annotation) %in% dmTP53$DepMap_ID, TRUE, FALSE)
annotation$has_ARID1A <- ifelse(rownames(annotation) %in% dmARID1A$DepMap_ID, TRUE, FALSE)
annotation$has_ATM <- ifelse(rownames(annotation) %in% dmATM$DepMap_ID, TRUE, FALSE)
annotation$has_BAI1 <- ifelse(rownames(annotation) %in% dmBAI1$DepMap_ID, TRUE, FALSE)
annotation$has_PTPRF <- ifelse(rownames(annotation) %in% dmPTPRF$DepMap_ID, TRUE, FALSE)
annotation$has_SYNE1 <- ifelse(rownames(annotation) %in% dmSYNE1$DepMap_ID, TRUE, FALSE)
annotation$has_THBS3 <- ifelse(rownames(annotation) %in% dmTHBS3$DepMap_ID, TRUE, FALSE)

#to be continued


```



```{r}
library(dendextend)  # we need this package to create tree diagrams

topVar = apply(kd.prob, 1, var)
tree = kd.prob[topVar > quantile(topVar, probs = 0.75),] 
anno <- annotation
rm(topVar)

#to use the function colored_Bars the row and colnames have to be transformed to integer values
colnames(tree) <- c(1:34)
rownames(anno) <- c(1:34)


#the following code calculates the hierachical cluster and plots it

cor.mat = cor(tree, method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)

plot(cor.hc, las = 2, cex.lab = 0.7)


#to get a good overview we add colored bars under the cluster
#the following code defines colors for our 7 main Drivermutations


cb7 <- ifelse(anno$has_TP53 == "TRUE", "forestgreen", "firebrick")
cb6 <- ifelse(anno$has_ARID1A == "TRUE", "forestgreen", "firebrick")
cb5 <- ifelse(anno$has_ATM == "TRUE", "forestgreen", "firebrick")
cb4 <- ifelse(anno$has_PTPRF == "TRUE", "forestgreen", "firebrick")
cb3 <- ifelse(anno$has_BAI1 == "TRUE", "forestgreen", "firebrick")
cb2 <- ifelse(anno$has_SYNE1 == "TRUE", "forestgreen", "firebrick")
cb1 <- ifelse(anno$has_THBS3 == "TRUE", "forestgreen", "firebrick")

#we have to bind them in one variable
cb <- cbind(`THBS3` = cb1, `SYNE1` = cb2, `BAI1` = cb3, `PTPRF` = cb4, `ATM` = cb5, `ARID1A` = cb6, `TP53` = cb7)

#and add it to the cluster
colored_bars(colors = cb, dend = cor.hc)

```



The next step is only possible with less than seven Mutations. Because otherwise there would be too many combinations of Drivermutations. In the Tree-Diagramm we performed in step 4 it is visible that many Drivermutations, especially the ones that occur only five times in our cell lines, occur very randomly along the cell lines. Caused by this fact we validated our seven mutations and choosed the ones that were mentioned in an Ovarian cancer context in literature. The following are our chosen ones: TP53, ARID1A, ATM and PTPRF. We continue the PCA analysis:

```{r}
#to investigate which cell lines contain which drivermutation we create a new data frame containing only the colums about our four Drivermutations
annodm <- annotation[, -which(colnames(annotation) %in% c("CCLE_Name", "Subtype.Disease", "has_BAI1", "has_SYNE1", "has_THBS3"))]


#to seperate the cell lines in groups with similar Mutations we give every Drivermutation a specific value: If TP53 is True in the cell line it gets a "1000" , if it isnt ther will be a "0"
annodm$has_TP53 <- ifelse(rownames(annotation) %in% dmTP53$DepMap_ID, 1000, 0)


#same here, ARID1A gets a "100" for True and a "0" for FALSE
annodm$has_ARID1A <- ifelse(rownames(annotation) %in% dmARID1A$DepMap_ID, 100, 0)

#and the same for the next Mutations
annodm$has_ATM <- ifelse(rownames(annotation) %in% dmATM$DepMap_ID, 10, 0)
annodm$has_PTPRF <- ifelse(rownames(annotation) %in% dmPTPRF$DepMap_ID, 1, 0)


#we can now sum up these values in a new column
annodm$summe <- apply(annodm, 1, function(x) { sum(x)})

```
We can now use the following order to take a look at our co existing Mutations

```{r}
View(annodm$summe)
```

We can now see that many cell lines dont even have one of our chosen mutations because their sum is zero. At many others we can see that they have the same combination of Drivermutations because they have the same value at "annodm$summe".
In the following step we gave the different combinations a specific category

```{r}

#we picked the most common combinations and gave them different categories by their sums

annodm$kat <- ifelse(annodm$summe == 1000, "TP53 only", ifelse(annodm$summe > 1099, "TP53 & ARID1A", ifelse(annodm$summe == 100, "ARID1A only", ifelse(annodm$summe == 110, "ARID1A & sec. Mu", ifelse(annodm$summe == 101, "ARID1A & sec. Mu", ifelse(annodm$summe < 100, "no TP53 & no ARID1A", ifelse(annodm$summe == 0, "no TP53 & no ARID1A", "TP53 & sec. Mu")))))))



#we also gave them different colors by using the same function as before

pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "green",  ifelse(annodm$summe == 100, "orange",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red",  ifelse(annodm$summe < 100, "grey",ifelse(annodm$summe == 0, "grey","darkblue")))))))


#and we added another column to the matrix containing that colors

annodm$col <- pcb


```



## 5. Synthetic Lethality Interactions
After identifying our most common driver mutations, we used this information to find possible synthetic lethality interaction partners
First of all, we want to calculate the variance of the cell survival (kd.ceres) and estimated cell survival probability (kd.prob) when knocking out specific genes. We hereby assume that genes that display high variances when knocked out are more likely to have specific synthetic lethality interactions since genes that broadly lead to cell death in most cell lines are probably essential for survival on their own. Therefore, we will conduct the search for synthetic lethality interaction partners with genes whose variances are greater than the 75% quantile.

```{r}
topVar = apply(kd.prob, 1, var) # calculate variance over all rows (genes)
summary(topVar)
kd.prob.topVar = kd.prob[topVar > quantile(topVar, probs = 0.75), ] # new data frame with just the genes whose knockout leads to highly variant cell death events -> perhaps our synthetic lethality interaction partners?
dim(kd.prob.topVar) # show me how many genes we are looking at now

#we do the same for the kd.ceres matrix for later analysis
topVar = apply(kd.ceres, 1, var)
kd.ceres.topVar = kd.ceres[topVar > quantile(topVar, probs = 0.75), ]


mean.survival.prob <- apply(kd.prob.topVar, 1, mean) # calculate the mean cell survival probability of the remaining genes
summary(mean.survival.prob) # show me the mean survival distribution of the genes whose knockout leads to the most variant cell survival

plot(density(as.matrix(mean.survival.prob))) # plot me the distribution of cell survival probability of most variant survivals

#wei? noch nicht, wie sinnvoll das alles ist :D mal sehen
# ja lass des mal drin ich hab des f?r den n?chsten step der PCA benutzt... also die kd.prob.topVar  mfG Marco


```

Alternative Idea: Wir nehmen unsere 7 Driver mutations (TP53, ARID1A, ATM, BAI1, PTPRF, SYNE1, THBS3) und teilen die Matrix kd.prob in zwei Submatrizen: eine, in der alle Zelllinien enthalten sind, die Driver mutations besitzen (23 von 34); und eine, wo die restlichen Zelllinien drin sind (11 von 34). Als nächstes werden ähnliche "Verhaltensmuster" unter den DM-Zelllinien gesucht: Erst werden alle Gene aussortiert, die eine hohe Varianz (oder hohe Differenz zw. Max und Min-Wert) haben (schließlich suchen wir SL partner, die möglichst oft zum Tod führen), und dann jene, wo das mittlere Überleben hoch ist => Man hat nur noch Gene, deren Knockout möglichst oft tödlich ist.

Jedoch muss gewährleistet sein, dass diese potenziellen SL partner keine allgemein essentiellen Gene sind, die auch ohne die Existenz von Driver mutations zum Zelltod führen. Daher behandelt man die Matrix mit den non-Driver-mutations-Zelllinien genauso, sodass man am Ende auch hier die Gene behält, deren Knockout durchgängig tödlich ist.
Nun kann man beide Data frames vergleichen - jene Gene, die in beiden Matrizen zum Tod führen, können keine spezifischen SL partner für die Driver mutations sein. Jedoch besteht die Chance, dass der Knockout jener Gene, die nur in der DM Matrix auftauchen, auch nur dort (und wegen der DM) tödlich wirkt. Das wären dann die SL partner.
Genauere Analysen könnte man noch mit Subsetten durchführen, indem man aufteilt in "Zelllinien mit TP53-Mutation" (ersetze jeweils mit einer anderen DM) und "Zelllinien ohne TP53-Mutation".

```{r}
nonDM <- kd.prob[, -which(colnames(kd.prob) %in% dm$DepMap_ID)] # prob Matrix with cell lines that do not have at least one of the 7 driver mutations
yesDM <- kd.prob[, which(colnames(kd.prob) %in% dm$DepMap_ID)] # prob matrix with cell lines that do have driver mutations

# Steps:
# 1. clean out high variance or those genes that have high difference between min and max survival

Var.nonDM = apply(nonDM, 1, var) # calculate variance over all rows (genes)
low.nonDM = nonDM[Var.nonDM < quantile(Var.nonDM, probs = 0.5), ] # low variance in behaviour (live or die) upon knockout

Var.yesDM = apply(yesDM, 1, var) # calculate variance over all rows (genes) for the knockout matrix with dm containing cell lines
low.yesDM = yesDM[Var.yesDM < quantile(Var.yesDM, probs = 0.5), ] # low variance in behaviour (live or die) upon knockout

# 2. Clean out genes with high survival rates (we want lethal knockouts)

Mean = rowMeans(low.nonDM) # calculate mean survival probability (high values: essential gene, knowckout is deadly)
low.nonDM <- low.nonDM[which(Mean > 0.5), ] # exclude genes that lead to survival upon knockout

Mean2 = rowMeans(low.yesDM) # calculate mean survival probability (high values: essential gene, knowckout is deadly)
low.yesDM <- low.yesDM[which(Mean2 > 0.5), ] # exclude genes that lead to survival upon knockout

# 3. compare both matrixes: genes that only lead to death in yesDM but not in nonDM could possibly be our synthetic lethality partners

# Only genes, who are present in all dataframes, can be included for the linear regression model. There for we first established a list, which contains all three dataframes. This step allows to extract the shared genes in both dataframes in a more effectiv way.

common.genes <- list(nonDM, yesDM ) # bind dataframes in one list
names(common.genes) <- c("nonDM","yesDM" ) # rename the elements of the list

# Next we will only extraxt genes, that are common in all three dataframes. Therefore all identical rownames/ genes were collated in one object/value

common.names = Reduce(intersect, lapply(common.genes, row.names)) # all common rownames in the three dataframes

'%ni%' <- Negate('%in%')
not.common.genes <- lapply(common.genes, function(x) {x[row.names(x) %ni% common.names,]}) # new list reduced to only the unshared genes/ rownames

dim(not.common.genes$nonDM) # find out if there are genes that don't belong to the respective other list

rm(nonDM, yesDM, Var.nonDM, Var.yesDM, low.nonDM, low.yesDM, Mean, Mean2, common.genes, common.names, not.common.genes)

```

Sadly, there do not seem to be any genes among our data that lead to more cell death in cells with designated driver mutations. However, it remains to be checked whether the experimentally found synthetic lethality interaction partner from our literature for ARID1A - BRD2 - can be affirmed here. We will therefore divide all cell lines into the two groups "yesARID1A" and "nonARID1A".
```{r}
dmARID1A = dm[which(dm$Hugo_Symbol == "ARID1A"), ]
nonARID1A <- kd.prob[, -which(colnames(kd.prob) %in% dmARID1A$DepMap_ID)] # prob Matrix with cell lines that do not have the ARID1A mutation
yesARID1A <- kd.prob[, which(colnames(kd.prob) %in% dmARID1A$DepMap_ID)] # prob matrix with cell lines that do have driver mutations

# Steps:
# 1. clean out high variance or those genes that have high difference between min and max survival

Var.nonARID1A = apply(nonDM, 1, var) # calculate variance over all rows (genes)
low.nonARID1A = nonARID1A[Var.nonARID1A < quantile(Var.nonARID1A, probs = 0.3), ] # low variance in behaviour (live or die) upon knockout

Var.yesARID1A = apply(yesARID1A, 1, var) # calculate variance over all rows (genes) for the knockout matrix with dm containing cell lines
low.yesARID1A = yesARID1A[Var.yesARID1A < quantile(Var.yesARID1A, probs = 0.3), ] # low variance in behaviour (live or die) upon knockout

# 2. Clean out genes with high survival rates (we want lethal knockouts)

Mean = rowMeans(low.nonARID1A) # calculate mean survival probability (high values: essential gene, knowckout is deadly)
low.nonARID1A <- low.nonARID1A[which(Mean.A > 0.7), ] # exclude genes that lead to survival upon knockout

Mean2 = rowMeans(low.yesARID1A) # calculate mean survival probability (high values: essential gene, knowckout is deadly)
low.yesARID1A <- low.yesARID1A[which(Mean.A2 > 0.7), ] # exclude genes that lead to survival upon knockout

# 3. compare both matrixes: genes that only lead to death in yesDM but not in nonDM could possibly be our synthetic lethality partners

# Only genes, who are present in all dataframes, can be included for the linear regression model. There for we first established a list, which contains all three dataframes. This step allows to extract the shared genes in both dataframes in a more effectiv way.

common.genes <- list(nonARID1A, yesARID1A ) # bind dataframes in one list
names(common.genes) <- c("nonARID1A","yesARID1A" ) # rename the elements of the list

# Next we will only extraxt genes, that are common in all three dataframes. Therefore all identical rownames/ genes were collated in one object/value

common.names = Reduce(intersect, lapply(common.genes, row.names)) # all common rownames in the three dataframes

'%ni%' <- Negate('%in%')
not.common.genes <- lapply(common.genes, function(x) {x[row.names(x) %ni% common.names,]}) # new list reduced to only the unshared genes/ rownames

dim(not.common.genes$nonARID1A) # find out if there are genes that don't belong to the respective other list

rm(nonARID1A, yesARID1A, Var.nonARID1A, Var.yesARID1A, low.nonARID1A, low.yesARID1A, Mean, Mean2, common.genes, common.names, not.common.genes)

```
Since BRD2 cannot be identified as an SL partner this way, it remains to be found out which difference it makes for cancer cells to lose BRD2 expression when ARID1A is defect.
```{r}
no <- nonARID1A[which(row.names(nonARID1A) == "BRD2"), ]
apply(no, 1, mean)
yes <- yesARID1A[which(row.names(yesARID1A) == "BRD2"), ]
apply(yes, 1, mean)

rm(no, yes)

```
The output says that BRD2 is about 10% more essential in ARID1A mutated cells...
Perhaps this is due to the fact that in the literature, BRD2 was mentioned as a SL partner explicitly in clear cell carcinomas. Our data comprise of different types of Ovarian cancer.

Other idea to find SL partners: calculate mean gene essentiality probability for both initially defined groups with/without driver mutations
and then ask for significant differences (with statistical test!).


Performing Principal Component Analysis

To reduce the information of the kd.prob matrix we perform a PCA. The Analysis creates groups of cell lines with similar lethality partners. We use the variable TopVar created before.

```{r}

#we use the colors defined in step 4 for our co existing mutations
pcb <- cbind(`TP` = pcb)

#keine Ahnung warum ich das machen muss ich frag david noch... aber ohne gehts net


#this function calculates the PCA with the variance calculated before
pca.prob = prcomp(kd.prob.topVar, center = F, scale. = F)

#we plot the pca with the different colors for cell lines with similar Driver Mutations
plot(pca.prob$rotation[, 1], pca.prob$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1", ylab = "PC2")

#we also add a legend to the plot
#to add the right colors to that legend we create a new dataframe containing the colors and the categories defined in step 4:

colors <- unique(annodm$col)
cat <- as.data.frame(colors)
cat$cat <- unique(annodm$kat)

legend("topright", pch = 20, col= cat$colors, legend = cat$cat, bty='n', cex=1.3)

#to have a comparisson we perform another PCA for the kd.ceres matrix
#therefore we use the kd.ceres.topvar value generated before

pca.ceres = prcomp(kd.ceres.topVar, center = F, scale. = F)

plot(pca.ceres$rotation[, 1], pca.ceres$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1", ylab = "PC2")

legend("topright", pch = 20, col= cat$colors, legend = cat$cat, bty='n', cex=1.3)

```





## 6. Linear Regression
In this step we wanted to investigate if it is possible to estimate the gene expression of a gene based on the copynumber. First a linear regression model should show if this issue can be applied to the totality of our data set independent of the differences between the single genes. Another regression model will focus on the relationship between the gene expression and copy number for the driver mutation individually.

### 6.1 Regression model for all genes

#### 6.1.1 Structuring the data

In the first step the data frames copynumber, knock.down and expression were ordered alphabetically, this helps to gain a better overview of the reviewed genes.

```{r}
copynumber <- copynumber[order(rownames(copynumber)),]
expression <- expression[order(rownames(expression)),]
kd.ceres <- kd.ceres[order(rownames(kd.ceres)),]
kd.prob <- kd.prob[order(rownames(kd.prob)),]
```
Only genes, who are present in all dataframes, can be included for the linear regression model. There for we first established a list, which contains all three dataframes. This step allows to extract the shared genes in both dataframes in a more effectiv way.
```{r}
list_all.genes <- list(expression,copynumber) # bind all the dataframes in one list
names(list_all.genes) <- c("expression","copynumber") # rename the elements of the list
```
Next we will only extraxt genes, that are common in all three dataframes. Therefore all identical rownames/ genes were collated in one object/value
```{r}
common_names = Reduce(intersect, lapply(list_all.genes, row.names)) # all common rownames in the three dataframes
list_all.genes <- lapply(list_all.genes, function(x) {x[row.names(x) %in% common_names,]}) # new list reduced to only the shared genes/ rownames
```
To check if the process was succesful, the dimensions before and after the clean up process were compared.
```{r}
dim(expression)
dim(copynumber)
dim(kd.ceres)
dim(kd.prob)
```
The dimension of the primary dataframes shows 49070, 23299  and 17634 rows, which indicates the present of different genes in the dataframes. After the clean up all data frames contain 16970 genes and the 34 ovarian cancer cell lines
```{r}
dim(list_all.genes$expression)
dim(list_all.genes$copynumber)
dim(list_all.genes$kd.ceres)
dim(list_all.genes$kd.prob)

```

#### 6.1.2 Checking distribution 
##### Gene expression
As a requirement for the regression model the data sets have to show a normal distribution. For an visual assessment  a Q-Q-plot was used for each of the four variables. First all the expression values of the different cell lines are fused to one long column. 
The  new matrix exp1 only contains only two columns. The first column shows the original cell line of the listed expression value in the second column.
```{r}
exp1 <- melt.data.frame(list_all.genes$expression, variable_name = "cell line") #fuse all expression values to one long column
```
The new matix will be used to check the distribution of the gene expression. The q-q-plot compairs the quantils of an normal distribution with the distribution of our data set and therefor can be used to check normality of the expression data
```{r}
qqnorm(exp1$value) # plot the quantils of the dataset with the quantils of a gaussian distribution
qqline(exp1$value) # lines the ideal distributaion for a perfect normality of the dataset
```
The plot shows a high amount of expression values equal zero, which has a huge deviation of the ideal gaussian distribution for the expression data. In comparison to the perfect distribution the rest of the data points show a good fit for the regression model. To achieve a better fit the genes that contain expression values equal zero will be removed in the next step.
```{r}
list_all.genes$expression <- list_all.genes$expression[apply(list_all.genes$expression !=0, 1, all),] # removes all rows that contain a value = 0
```
With the melt function the reduced data set is fused to one column of values agian
```{r}
exp1 <- melt.data.frame(list_all.genes$expression, variable_name = "cell line") #fuse all expression values to one long column
```
A q-q-plot is peformed to check the normality of the expression data set once again and determine if the reduction process shows a improved result
```{r}
qqnorm(exp1$value) # plot the quantils of the dataset with the quantils of a gaussian distribution
qqline(exp1$value) # ideal line
```
While the plot indicates a higher accord with the peferct gaussian distribution, there is still a horizontal line pointing out a high amount of values near zero. To check for outliners ab boxplot is apllied for the expression data.
Even if the fit is not perfect, the regression model will be performed with this data points for the gene expression

##### Copy number
As describe in the paragraph above the distribution for the copy number of the genes has to be investigated. First the data is fused to a matrix with two columns
```{r}
cn1 <- melt.data.frame(list_all.genes$copynumber, variable_name = "cellline") # fuse all cell lines
```
Next the distribution is checked with a q-q-plot
```{r}
qqnorm(cn1$value) # create qqplot
qqline(cn1$value) # show ideal line for normality
```
The plot indicates a high deviation for vales approximately smaller than -1, to reduce the influence of this circumstance for the normality, all rows/ genes that show a value smaller than -2 or equal -2. There for we first created a vector with all genes, those contain one value smaller or equal -2
```{r}
rmv.rows = apply(list_all.genes$copynumber, 1, function(x) {sum(x <= -2)}) # find all genes with values <= -2
```
The vector is used to remove any gene, that has one or more values smaller/ equal to -2
```{r}
list_all.genes$copynumber <- list_all.genes$copynumber[-which(rmv.rows > 0), ] # remove all rows, those contain more than one value <= -2
```
To check the distribution once agian the separate cell lines must be fused to one long column
```{r}
cn1 <- melt.data.frame(list_all.genes$copynumber, variable_name = "cellline") # fuse all cell lines
```
The qq-plot reveals a better fit of the data set after the reduction process, although for copynumbers higher than one a strong aberration is revealed.
```{r}
qqnorm(cn1$value) # create qqplot
qqline(cn1$value) # ideal distributaion
```

#### Fuse the expression and copynumber
Before checking the correlation between the two variables, the common genes of both dataframes have to be identified for a second time. Only genes that are present in both dataframes can be used for the correlation test
```{r}
common_names = Reduce(intersect, lapply(list_all.genes, row.names)) # identify shared rownames
list_all.genes <- lapply(list_all.genes, function(x) {x[row.names(x) %in% common_names,]}) # only keep the common rownames in the new list
```
Because outliners can have a major impact on the validity of the regression model, both columns are checked with a boxplot.
```{r}
boxplot(exp1, cn1) # boxplot for expression and copynumber (nochmal option mit ggplot2 finden)
```
The graph indicates a high amount of outliners, this may lead to an inefficient model and therefore has two be considered in the testing process of the regression model.
Even both dataframes do not indicate a good fit for normality and show a high amount of outliners, futher analysis will be performed with the data set.

#### 6.1.3 Correlation between the two variables
In this step the correlation between the gene expression and copy number is tested, to decide wether a linear regression model can be applied for the problem. First all values for the gene expression and copy number are merged in one dataframe. There for the former established matices exp1 and cn1, but first tey have to be replaced after the wohle reduction process.
```{r}
exp1 <- melt.data.frame(list_all.genes$expression, variable_name = "cellline")
cn1 <- melt.data.frame(list_all.genes$copynumber, variable_name = "cellline")
```
The both columns containing the values for the gene expression and copynumber are merged in the data frame regression.all.genes
```{r}
# noch Zelllinie rein bekommen
regression.all.genes <- as.data.frame(cbind(exp1$value, cn1$value)) # merge the colums
colnames(regression.all.genes) <- c("expression", "copynumber") # rename the colums
```
To ensure a clean workspace the no longer needed data frames exp1 and cn1 are removed
```{r}
remove(exp1, cn1, commonnames, rmv.rows)
```
A Create a scatter to check the correlation between the two variables and correlation coefficient in the plot is ablined 
```{r}
ggplot(regression.all.genes, aes(x = copynumber, y = expression)) # create scatter plot with x = copynumber and y = expression
+ geom_point(color = "navy blue")+ stat_smooth(method = "lm", color = "red",se = FALSE, size = 1) # abline correlation between the two variables
+ labs(title = "Correlation between the gene expression and copynumber") # ingtegrate title
```
The scatter plot reveals a very low correlation between both variables, to further analyse the issue the person and spearman correlation coefficient is computed.
```{r}
cor(regression.all.genes$expression, regression.all.genes$copynumber) # compute person correlation 
cor(regression.all.genes$expression, regression.all.genes$copynumber, method = "spearman") # compute spearman correlation coefficient
```
Both correlation coefficients show a low correlation between the two varibles of approximately 0.07 to 0.08. The sligthly higher spearman correlation concludes, that the person correlation is lightly influenced by outliners.
To verify the correlation a t-test for both correlation coefficient is performed. The null hypothesis indicates that there is no correlation between the copy number and the gene expression, while the alternativ hypothesis confirms a correlation between the two variables. 
As a common level of significance ?? = 0,05 is choosen and a p-value, which is smaller than the level of significance, will lead to a denial of the null hypothesis. First the p-value for the person correlation coefficient is verified
```{r}
cor.test(regression.all.genes$expression, regression.all.genes$copynumber)
```
With a p-value < 2.2e-16 the null hypothesis can be rejected, becaue the p-value shows a way smaller value that the level of significance. Only in the case of a p-value that is higher than the level of significance the null hypothesis would be retained. The same analysis is performed for the spearman correlation coefficient
```{r}
cor.test(regression.all.genes$expression, regression.all.genes$copynumber, method = "spearman")
```
The test also shows a p-value < 2.2e-16, concluding the rejection of the null hypothesis. Both test lead to the conclusion, that the variables expression and copynumber have a low correlation and therefore could possibly be applied for a linear regression model.

#### 6.1.4 Univariate linear regression
Before using the regression.all.genes data for a regression model, a small amount of values have to be seperated for training purposes. The first twenty rows of the dataframe will be used as trainingsdata in a later step. 
```{r}
training.all.genes <- regression.all.genes[1:20,] # new dataframe with row 1-20 of dataframe regression.all.genes
```
Next the first twenty rows are removed from the original to exclude them from the regression model.
```{r}
regression.all.genes <- regression.all.genes[-c(1:20),] # remove row 1-20 
```
After the reduction process the data is integrated in the regression model lrm.all.genes. The variable copynumber is used as a predictor for the variable gene expression. 
```{r}
lrm.all.genes <- lm(expression ~ copynumber, data = regression.all.genes) #create linear regression model
summary(lrm.all.genes) # show regression model 
```

### 6.2 Regression model for all driver muatations

### 6.3 Regression model for the single driver mutations

#### 6.3.1 Structuring of the data

We only used the driver mutations, that show a frequency of 5 counts or higher for the linear regression models.
First a new dataframe with expression and copynumber for each driver mutation was established
```{r}
regression.driver <- data.frame(rbind(expression["TP53",], copynumber["TP53",], expression["ARID1A",], copynumber["ARID1A",], expression["ATM",], copynumber["ATM",], expression["BAI1",], copynumber["BAI1",], expression["PTPRF",], copynumber["PTPRF",], expression["SYNE1",], copynumber["SYNE1",], expression["THBS3", ], copynumber["THBS3",] ))
 # new dataframe, which contains expression and copynumber vor TP53 and ARID1Ablubereg
```
For an easy determination between the expression and the copy number of a gene, all the genes receive the index ex or cn. The index ex is used for the expression level while the index cn stands for the copynumber of the gene. 
```{r}
row.names(regression.driver)<- c("TP53ex", "TP53cn", "ARID1Aex", "ARID1Acn", "ATMex", "ATMcn", "BAI1ex", "BAI1cn", "PTPRFex", "PTPRFcn", "SYNE1ex", "SYNE1cn", "THBS3ex", "THBS3cn" ) # rename the rownames, differetiation between ex=expression and cn=copynumber
```
For an easier application the whole dataframe was transposed. Before this process the  columns listed the cell lines and the rows contained the genes.(After the transpose process it is the other way around.)
```{r}
reg.driver <- as.data.frame(t(reg.driver)) # transpose 
```
After a short overview with the view-function, the data frame indicates missing values for the expression level of BAI1. Because this gene can not be included in a regression model, it was removed from the data frame
```{r}
regression.driver <- regression.driver[, -which(colnames(regression.driver) %in% c("BAI1ex", "BAI1cn"))] # remove the columns of the gene BAI1

```

### 6.3.2 Analysis of the correlation and linear regression model

##### TP53
Before using the data of gene TP53 for a linear regression model, a few requirements have to be achieved by the two variables gene expression and copynumber
First both variables should be distributed normally. This circumstances was verified visual with an desity plot and a Q-Q-plot.
```{r}
plot(density(regression.driver$TP53ex), xlab = "expression level", main = "gene TP53") + abline(v = summary(regression.driver$TP53ex)[2:5], col = c("blue", "red", "black", "orange"), lty = 2) # density plot with 1st quantil, median, mean and 3rd quantil
```
Next a qq-plot was performed
```{r}
qqnorm(regression.driver$TP53ex)
qqline(regression.driver$TP53ex)
```
same question?

To check the correlation between the expression and copynumber of the gene TP53 --> scatterplot with correlation
```{r}
plot(TP53cn ~ TP53ex, data = regression.driver, xlab= "expression", ylab = "copynumber", main="TP53", col="blue") + abline(lm(TP53cn~TP53ex, data = regression.driver), col="red") # scatter plot with the line for the pearson correlation coefficient
```
The visual overview of the scatter plot does not conclude a high correlation between the gene expression and the copy number of TP53. To further ceck the correlation, the pearson correlation coefficient was estimated.
```{r}
cor(regression.driver$TP53ex, regression.driver$TP53cn) # compute pearson correlation

```

The value of approximately 0.47 for the pearson correlation coefficient concludes a weak/ moderate positive linear relationship between the two variables. To avoid a strong influence of outliners the spearman correlation to check the correlation a second time. This method will transform the values of each Variable in ranks
```{r}
cor(regression.driver$TP53ex, regression.driver$TP53cn, method = "spearman") # compute spearman correlation

```
The spearman correlation results with approximately 0.37 in an even lower value for the correlation. 

### 6.3 Significance of the correlation coefficient
### 6.4 Creation of a linear regression model
### 6.5 Verfication of the model
## 7. Summary of Results
## 8. Conclusion