---
title: 'Project 3: Ovarian Cancer'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Contents
1. Overview Ovarian Cancer
2. Data Cleanup
3. Driver Mutations
4. co-existing Mutations
5. Synthetic Lethality Interactions
6. Linear Regression
7. Summary of Results
8. Conclusion

## 1. Overview Ovarian Cancer

### 1.1 General facts
Ovarian cancer is a very heterogenous disease.lol

## 2. Data Cleanup

first we downloaded the data and load data in R
```{r}
allDepMapData <- readRDS("~/GitHub/project-01-group-03/DepMap19Q1_allData.RDS")
```
rename the lists from the main data
```{r}
copynumber = allDepMapData[["copynumber"]]
mutation = allDepMapData[["mutation"]]
kd.ceres = allDepMapData[["kd.ceres"]]
kd.prob = allDepMapData[["kd.prob"]]
annotation = allDepMapData[["annotation"]]
expression = allDepMapData[["expression"]]

```
extract all cell lines that have ovarian cancer as primary disease. 
```{r}
annotation = annotation[which(annotation$Primary.Disease == "Ovarian Cancer"), ] # The annotation matrix now only consists of Ovarian Cancer cell lines
ID = annotation$DepMap_ID # DepMap_ID is the column name for the Ovarian Cancer cell lines
expression = expression[ , which(colnames(expression) %in% ID)] # Extract the expression column from ID and re-define the data frame called expression. Do the same for the columns copynumber, kd.ceres and kd.prob. (Stimmt das?)
copynumber = copynumber [ , which(colnames(copynumber) %in% ID)]
kd.ceres = kd.ceres [ , which(colnames(kd.ceres) %in% ID)]
kd.prob = kd.prob [ , which(colnames(kd.prob) %in% ID)]
mutation = mutation [ ID]
```


remove the object allDepMapData for a clean workflow
```{r}
rm(allDepMapData)
```

Remove unnecessary cols of the annotation matrix and rename the rows with the cell lines
```{r}
rownames(annotation) = annotation$DepMap_ID
annotation = annotation[, -which(colnames(annotation) %in% c("DepMap_ID", "Aliases", "Primary.Disease", "Gender", "Source"))]

```

check the matrices if they contain any NA values and delete the containing rows

```{r}
#summary(copynumber) hier m?ssen wirs hinkriegen dass er den output net reinhaut


NAV = apply(copynumber, 1, function(x) {sum(is.na(x))}) 
copynumber = copynumber[-which(NAV > 0), ]  

#hier muss ich nochmal gucken ob man des machen muss weil iwi passiert da was komisches

#NAV = apply(expression, 1, function(x) {sum(is.na(x))}) 
#expression = expression[-which(NAV > 0), ]  
 
#NAV = apply(kd.ceres, 1, function(x) {sum(is.na(x))}) 
#kd.ceres = kd.ceres[-which(NAV > 0), ]

#NAV = apply(kd.prob, 1, function(x) {sum(is.na(x))}) 
#kd.prob = kd.prob[-which(NAV > 0), ]
```


## 3. Driver Mutations


Fuse mutation lists to one matrix
```{r}
mutation.all = as.data.frame(rbindlist(mutation))
```

Our analyses just need the information in certain columns of our data frame, for example gene name and location (chromosome), cell line, the kind of mutation (missense, frame shift, etc.). Thus, we extract these columns and put them in the data frame "mutation.all".
```{r}
 mutation.all = mutation.all[, which(colnames(mutation.all) %in% c("Hugo_Symbol", "DepMap_ID", "Variant_Classification", "Variant_annotation", "isTCGAhotspot", "Chromosome", "isDeleterious"))]
```
There are different types of mutations. Some of them are silent, which means that the amino acid sequence is not altered and the protein structure is not affected. Other mutations lead to an amino acid exchange, but do not provoke dramatic conformational changes in the encoded protein. Whether or not a mutation has an impact on protein function is noted in the column "isDeleterious". We want to extract all mutations that are TRUE for isDeleterious, since these might have something to do with cancer cell development.
```{r}
mutation.all = mutation.all[which(mutation.all$isDeleterious == "TRUE"), ] # only include rows (=genes) that have deleterious mutations in data frame "mutation.all"
```
Order matrix alphabetically

```{r}
mutation.all <- mutation.all[order(mutation.all$Hugo_Symbol),]

```

Find most frequently mutated genes by summing up all "mutation events" found in all cell lines. To do this, the names of the genes were converted to factors.
```{r}
mutation.all$Hugo_Symbol = factor(mutation.all$Hugo_Symbol)

summary(mutation.all$Hugo_Symbol)

```
Plot all mutations to see most frequently mutated genes
```{r}
plot(mutation.all$Hugo_Symbol)
```

However, this does not look very nice. How can we solely plot genes that are mutated more than e.g. 5 times in total?

```{r}
DriverMutation <- as.data.frame(table(new_uniq$Hugo_Symbol))
DriverMutation = DriverMutation[which(DriverMutation$Freq > 4), ]
DriverMutation <- DriverMutation[order(DriverMutation$Freq, decreasing = TRUE),]
barplot(DriverMutation$Freq, names.arg = DriverMutation$Var1, xlab="mutated Gene", las = 1, horiz=FALSE, cex.axis = 1,2, col = "lightblue", main = "mutations present in more than four cell lines", ylab = "frequency")



```


The most common mutation is found in ARID1A (16 times). Surprisingly, BRCA1 and BRCA2 are only mutated twice and once, respectively.

Problem: Many mutations occur several times in one cell line, but in different DNA loci. If we want to identify the most frequent mutations among all cell lines, these duplicates should not be included. We want to extract mutations that occur frequently in different cell lines. Therefore, we use the "duplicated" function from the dplyr package and define a new data frame called new_uniq that only contains one mutation of a gene per cell line for simplicity (since the type of mutation is not relevant here).

```{r}
duplicates <- which(duplicated(mutation.all[c('Hugo_Symbol', 'DepMap_ID')]), ) #find all identical combinations of mutated gene and cell line
duplicates # show all genes that are duplicated
new_uniq <- mutation.all[!duplicated(mutation.all[c('Hugo_Symbol', 'DepMap_ID')]),] #do not include duplicates in data frame new_uniq
summary(new_uniq)

```
As we can see, ARID1A is only the second most common mutation after TP53, which is mutated in 12 of 34 different cell lines. The most common mutations among our cell lines are thought to be our driver mutations. We will be conducting further analyses with these genes.

## 4. Co-existing Mutations

```{r}
library(dendextend)  # we need this package to create tree diagrams

tree <- expression[which(rownames(expression) %in% DriverMutation$Var1), ]
#neue Matrix belegen, damit expression nicht überschribene wird
# aber komischerweise fehlt ein mutiertes Gen in der Expression BAI... ???

cor.mat = cor(tree, method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)


plot(cor.hc, las = 2, cex.lab = 0.7)


cb1 <- ifelse(annotation == "Adenocarcinoma", "forestgreen", "firebrick")
cb <- cbind(`Adeno` = cb1)
plot(cor.hc, las = 2, cex.lab = 0.7)
colored_bars(colors = cb, dend = cor.hc)

# David fragen warum das nicht funktioniert, beim 3FS Kurs hats geklappt
#http://bioinfo.ipmb.uni-heidelberg.de/crg/datascience3fs/practicals/2_UnsupervisedLearning.html#hierarchical-clustering

```


## 5. Synthetic Lethality Interactions
After identifying our most common driver mutations, we used this information to find possible synthetic lethality interaction partners

## 6. Linear Regression

### 6.1 Structuring of the data

In this step we wanted to investigate if it is possible to estimate the gene expression of a driver mutation based on the copynumber of the gene.
We will only use the driver mutations, that show a frequency of 5 counts or higher for the linear regression models.
First a new dataframe with expression and copynumber for each driver mutation was established
```{r}
regression.driver <- data.frame(rbind(expression["TP53",], copynumber["TP53",], expression["ARID1A",], copynumber["ARID1A",], expression["ATM",], copynumber["ATM",], expression["BAI1",], copynumber["BAI1",], expression["PTPRF",], copynumber["PTPRF",], expression["SYNE1",], copynumber["SYNE1",], expression["THBS3", ], copynumber["THBS3",] ))
 # new dataframe, which contains expression and copynumber vor TP53 and ARID1Ablubereg
```
For an easy determination between the expression and the copy number of a gene, all the genes receive the index ex or cn. The index ex is used for the expression level while the index cn stands for the copynumber of the gene. 
```{r}
row.names(regression.driver)<- c("TP53ex", "TP53cn", "ARID1Aex", "ARID1Acn", "ATMex", "ATMcn", "BAI1ex", "BAI1cn", "PTPRFex", "PTPRFcn", "SYNE1ex", "SYNE1cn", "THBS3ex", "THBS3cn" ) # rename the rownames, differetiation between ex=expression and cn=copynumber
```
For an easier application the whole dataframe was transposed. Before this process the  columns listed the cell lines and the rows contained the genes.(After the transpose process it is the other way around.)
```{r}
reg.driver <- as.data.frame(t(reg.driver)) # transpose 
```

### 6.2 Analysis of the correlation


#### TP53
first scatterplot for visual overview. correlation

### 6.3 Significance of the correlation coefficient
### 6.4 Creation of a linear regression model
### 6.5 Verfication of the model
## 7. Summary of Results
## 8. Conclusion