View(anno)
annodm$has_ARID1A <- ifelse(rownames(anno) %in% dmARID1A$DepMap_ID, 100, 0)
View(anno)
annodm$has_ATM <- ifelse(rownames(anno) %in% dmATM$DepMap_ID, 10, 0)
annodm$has_PTPRF <- ifelse(rownames(anno) %in% dmPTPRF$DepMap_ID, 1, 0)
annodm$summe <- apply(annodm, 1, function(x) { sum(x)})
View(annodm)
annodm$kat <- ifelse(annodm$summe == 1000, "nTP", ifelse(annodm$summe > 1099, "TP+AR", ifelse(annodm$summe == 100, "nAR", ifelse(annodm$summe == 110, "AR+AT", ifelse(annodm$summe == 101, "AR+PT", ifelse(annodm$summe < 100, "nTP+AR", ifelse(annodm$kat == 0, "TP+SM", "nix")))))))
View(annodm)
annodm$kat <- ifelse(annodm$summe == 1000, "nTP", ifelse(annodm$summe > 1099, "TP+AR", ifelse(annodm$summe == 100, "nAR", ifelse(annodm$summe == 110, "AR+AT", ifelse(annodm$summe == 101, "AR+PT", ifelse(annodm$summe < 100, "nTP+AR", ifelse(annodm$kat == 0, "TP+SM", "nn")))))))
View(annodm)
annodm$kat <- ifelse(annodm$summe == 1000, "nTP", ifelse(annodm$summe > 1099, "TP+AR", ifelse(annodm$summe == 100, "nAR", ifelse(annodm$summe == 110, "AR+AT", ifelse(annodm$summe == 101, "AR+PT", ifelse(annodm$summe < 100, "nTP+AR", ifelse(annodm$kat == 0, "TP+SM", 0)))))))
View(annodm)
pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "purple", ifelse(annodm$summe == 100, "pink",  ifelse(annodm$summe == 101, "red", ifelse(annodm$summe < 100, "grey", "white")))))
pcb <- cbind(`TP` = pcb)
annodm$col <- pcb
View(annodm)
pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "purple", ifelse(annodm$summe == 100, "pink",  ifelse(annodm$summe == 101, "red", ifelse(annodm$summe < 100, "grey", "lightblue")))))
pcb <- cbind(`TP` = pcb)
View(annodm)
annodm$col <- pcb
View(annodm)
View(anno1)
topVar = apply(kd.prob, 1, var) # calculate variance over all rows (genes)
summary(topVar)
kd.prob.topVar = kd.prob[topVar > quantile(topVar, probs = 0.75), ] # new data frame with just the genes whose knockout leads to highly variant cell death events -> perhaps our synthetic lethality interaction partners?
dim(kd.prob.topVar) # show me how many genes we are looking at now
mean.survival.prob <- apply(kd.prob.topVar, 1, mean) # calculate the mean cell survival probability of the remaining genes
summary(mean.survival.prob) # show me the mean survival distribution of the genes whose knockout leads to the most variant cell survival
plot(density(as.matrix(mean.survival.prob))) # plot me the distribution of cell survival probability of most variant survivals
#weiÃŸ noch nicht, wie sinnvoll das alles ist :D mal sehen
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
plot(pca$rotation[, 1], pca$rotation[, 2], pch = 19, xlab = "PC1",      ylab = "PC2")
topVar = apply(kd.ceres, 1, var) # calculate variance over all rows (genes)
summary(topVar)
kd.prob.topVar = kd.ceres[topVar > quantile(topVar, probs = 0.75), ]
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
plot(pca$rotation[, 1], pca$rotation[, 2], pch = 19, xlab = "PC1",      ylab = "PC2")
topVar = apply(kd.prob, 1, var) # calculate variance over all rows (genes)
summary(topVar)
kd.prob.topVar = kd.prob[topVar > quantile(topVar, probs = 0.75), ] # new data frame with just the genes whose knockout leads to highly variant cell death events -> perhaps our synthetic lethality interaction partners?
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
plot(pca$rotation[, 1], pca$rotation[, 2], pch = 19, xlab = "PC1",      ylab = "PC2")
```
topVar = apply(kd.prob, 1, var)
tree = kd.prob[topVar > quantile(topVar, probs = 0.75),]
#to use the function colored_Bars the row and colnames have to be transformed to integer values
colnames(tree) <- c(1:34)
rownames(anno1) <- c(1:34)
#the following code calculates the hierachical cluster and plots it
cor.mat = cor(tree, method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)
plot(cor.hc, las = 2, cex.lab = 0.7)
#to get a good overview we add colored bars under the cluster
#the following code defines colors for our 7 main Drivermutations
cb7 <- ifelse(anno$has_TP53 == "TRUE", "forestgreen", "firebrick")
cb6 <- ifelse(anno$has_ARID1A == "TRUE", "forestgreen", "firebrick")
cb5 <- ifelse(anno$has_ATM == "TRUE", "forestgreen", "firebrick")
cb4 <- ifelse(anno$has_PTPRF == "TRUE", "forestgreen", "firebrick")
cb3 <- ifelse(anno$has_BAI1 == "TRUE", "forestgreen", "firebrick")
cb2 <- ifelse(anno$has_SYNE1 == "TRUE", "forestgreen", "firebrick")
cb1 <- ifelse(anno$has_THBS3 == "TRUE", "forestgreen", "firebrick")
#we have to bind them in one variable
cb <- cbind(`THBS3` = cb1, `SYNE1` = cb2, `BAI1` = cb3, `PTPRF` = cb4, `ATM` = cb5, `ARID1A` = cb6, `TP53` = cb7)
#and add it to the cluster
colored_bars(colors = cb, dend = cor.hc)
cb4 <- ifelse(anno$has_TP53 == "TRUE", "forestgreen", "firebrick")
cb3 <- ifelse(anno$has_ARID1A == "TRUE", "forestgreen", "firebrick")
cb2 <- ifelse(anno$has_ATM == "TRUE", "forestgreen", "firebrick")
cb1 <- ifelse(anno$has_PTPRF == "TRUE", "forestgreen", "firebrick")
cb <- cbind(`PTPRF` = cb1, `ATM` = cb2, `ARID1A` = cb3, `TP53` = cb4)
plot(cor.hc, las = 2, cex.lab = 0.7)
colored_bars(colors = cb, dend = cor.hc)
topVar = apply(kd.prob, 1, var)
tree = kd.prob[topVar > quantile(topVar, probs = 0.75),]
#to use the function colored_Bars the row and colnames have to be transformed to integer values
colnames(tree) <- c(1:34)
rownames(anno1) <- c(1:34)
#the following code calculates the hierachical cluster and plots it
cor.mat = cor(tree, method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)
plot(cor.hc, las = 2, cex.lab = 0.7)
#to get a good overview we add colored bars under the cluster
#the following code defines colors for our 7 main Drivermutations
cb7 <- ifelse(anno$has_TP53 == "TRUE", "forestgreen", "firebrick")
cb6 <- ifelse(anno$has_ARID1A == "TRUE", "forestgreen", "firebrick")
cb5 <- ifelse(anno$has_ATM == "TRUE", "forestgreen", "firebrick")
cb4 <- ifelse(anno$has_PTPRF == "TRUE", "forestgreen", "firebrick")
cb3 <- ifelse(anno$has_BAI1 == "TRUE", "forestgreen", "firebrick")
cb2 <- ifelse(anno$has_SYNE1 == "TRUE", "forestgreen", "firebrick")
cb1 <- ifelse(anno$has_THBS3 == "TRUE", "forestgreen", "firebrick")
#we have to bind them in one variable
cb <- cbind(`THBS3` = cb1, `SYNE1` = cb2, `BAI1` = cb3, `PTPRF` = cb4, `ATM` = cb5, `ARID1A` = cb6, `TP53` = cb7)
#and add it to the cluster
colored_bars(colors = cb, dend = cor.hc)
View(dm)
table(dm$DepMap_ID)
View(annodm)
pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "purple", ifelse(annodm$summe == 100, "pink",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red", ifelse(annodm$summe < 100, "green", ifelse(annodm$summe == 0, "grey","lightblue")))))
pcb <- cbind(`TP` = pcb)
annodm$kat <- ifelse(annodm$summe == 1000, "TP_only", ifelse(annodm$summe > 1099, "TP+AR", ifelse(annodm$summe == 100, "AR_only", ifelse(annodm$summe == 110, "AR+AT", ifelse(annodm$summe == 101, "AR+PT", ifelse(annodm$summe < 100, "no_TP+no_AR", ifelse(annodm$summe == 0, "nix", "TP+SM")))))))
View(annodm)
pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "purple",  ifelse(annodm$summe == 100, "pink",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red", ifelse(annodm$summe < 100, "green", ifelse(annodm$summe == 0, "grey","lightblue")))))))
pcb <- cbind(`TP` = pcb)
View(annodm)
topVar = apply(kd.prob, 1, var)
prob.topVar = kd.prob[topVar > quantile(topVar, probs = 0.75), ]
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "purple",  ifelse(annodm$summe == 100, "pink",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red", ifelse(annodm$summe == 11, "green", ifelse(annodm$summe == 10, "grey",ifelse(annodm$summe == 0, "grey","lightblue"))))))))
pcb <- cbind(`TP` = pcb)
topVar = apply(kd.prob, 1, var)
prob.topVar = kd.prob[topVar > quantile(topVar, probs = 0.75), ]
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
help(plot)
help(prcomp)
legend("topleft", pch = 20, col=pcb, legend = c("Day 1","Day 2","Day 3","Day 4","Day 5","Day 6"), bty='n', cex=.75)
legend("topright", pch = 20, col=pcb, legend = c("Day 1","Day 2","Day 3","Day 4","Day 5","Day 6"), bty='n', cex=.75)
topVar = apply(kd.prob, 1, var)
prob.topVar = kd.prob[topVar > quantile(topVar, probs = 0.75), ]
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topleft", col=1:10, legend = paste("Day", 1:10),
pch = 20, bty='n', cex=.75)
topVar = apply(kd.prob, 1, var)
prob.topVar = kd.prob[topVar > quantile(topVar, probs = 0.75), ]
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
help(legend)
legend("topright", pch = 20, col= c("blue", "lightblue"), legend = c("Day 1","Day 2"), bty='n', cex=.75)
topVar = apply(kd.prob, 1, var)
prob.topVar = kd.prob[topVar > quantile(topVar, probs = 0.75), ]
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & SM", "ARID1A only", "ARID1A & SM", "TP53 & ARID1A", "no TP53 & no ARID"), bty='n', cex=.75)
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
#we plot the pca with the different colors for cell lines with similar Driver Mutations
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
ggplot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
library(ggplot2)
ggplot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
ggplot(pca$rotation[, 1], pca$rotation[, 2], aes(hwy, cty)) + geom_point(aes(color = pcb))
p <-ggplot (pca,aes(x=PC1,y=PC2,color=pcb ))
p <-ggplot (pcamat,aes(x=PC1,y=PC2,color=pcb ))
p
p<-p+geom_point()+theme + xlab(percentage[1]) + ylab(percentage[2]) + scale_color_manual(values=c("#FFFF00", "#00FFFF", "#FF00FF"))
p
load("~/GitHub/project-01-group-03/OCdata.RDS.RData")
rm(annodm)
rm(cb)
rm(dm)
View(dmARID1A)
rm(dmSYNE1, dmARID1A, dmATM)
rm(dmPTPRF, dmTHBS3, dmTP53, dmBAI1)
rm(pca)
rm(prob.topVar)
rm(anno)
rm(topvar)
rm(topVar)
rm(NAV)
rm(rmv.rows)
rm(cb1)
save.image("~/GitHub/project-01-group-03/OCdata.RDS.RData")
topVar = apply(kd.prob, 1, var)
tree = kd.prob[topVar > quantile(topVar, probs = 0.75),]
anno <- annotation
rm(topVar)
#to use the function colored_Bars the row and colnames have to be transformed to integer values
colnames(tree) <- c(1:34)
rownames(anno) <- c(1:34)
#the following code calculates the hierachical cluster and plots it
cor.mat = cor(tree, method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)
cb7 <- ifelse(anno$has_TP53 == "TRUE", "forestgreen", "firebrick")
cb6 <- ifelse(anno$has_ARID1A == "TRUE", "forestgreen", "firebrick")
cb5 <- ifelse(anno$has_ATM == "TRUE", "forestgreen", "firebrick")
cb4 <- ifelse(anno$has_PTPRF == "TRUE", "forestgreen", "firebrick")
cb3 <- ifelse(anno$has_BAI1 == "TRUE", "forestgreen", "firebrick")
cb2 <- ifelse(anno$has_SYNE1 == "TRUE", "forestgreen", "firebrick")
cb1 <- ifelse(anno$has_THBS3 == "TRUE", "forestgreen", "firebrick")
#we have to bind them in one variable
cb <- cbind(`THBS3` = cb1, `SYNE1` = cb2, `BAI1` = cb3, `PTPRF` = cb4, `ATM` = cb5, `ARID1A` = cb6, `TP53` = cb7)
#and add it to the cluster
colored_bars(colors = cb, dend = cor.hc)
plot(cor.hc, las = 2, cex.lab = 0.7)
cb7 <- ifelse(anno$has_TP53 == "TRUE", "forestgreen", "firebrick")
cb6 <- ifelse(anno$has_ARID1A == "TRUE", "forestgreen", "firebrick")
cb5 <- ifelse(anno$has_ATM == "TRUE", "forestgreen", "firebrick")
cb4 <- ifelse(anno$has_PTPRF == "TRUE", "forestgreen", "firebrick")
cb3 <- ifelse(anno$has_BAI1 == "TRUE", "forestgreen", "firebrick")
cb2 <- ifelse(anno$has_SYNE1 == "TRUE", "forestgreen", "firebrick")
cb1 <- ifelse(anno$has_THBS3 == "TRUE", "forestgreen", "firebrick")
#we have to bind them in one variable
cb <- cbind(`THBS3` = cb1, `SYNE1` = cb2, `BAI1` = cb3, `PTPRF` = cb4, `ATM` = cb5, `ARID1A` = cb6, `TP53` = cb7)
#and add it to the cluster
colored_bars(colors = cb, dend = cor.hc)
View(cb)
dm <- new_uniq[which(new_uniq$Hugo_Symbol %in% DriverMutation$Var1), ]
#and delete unnecesary columns
dm = dm[, -which(colnames(dm) %in% c("Chromosome", "isDeleterious", "Variant_annotation"))]
#lets check out how many Drivermutations are common in the cell lines
table(dm$DepMap_ID)
#to get acces to the single cell lines we have to create single matrices for every Drivermutation
dmTP53 = dm[which(dm$Hugo_Symbol == "TP53"), ]
dmARID1A = dm[which(dm$Hugo_Symbol == "ARID1A"), ]
dmATM = dm[which(dm$Hugo_Symbol == "ATM"), ]
dmBAI1 = dm[which(dm$Hugo_Symbol == "BAI1"), ]
dmPTPRF = dm[which(dm$Hugo_Symbol == "PTPRF"), ]
dmSYNE1 = dm[which(dm$Hugo_Symbol == "SYNE1"), ]
dmTHBS3 = dm[which(dm$Hugo_Symbol == "THBS3"), ]
#now we add new colums to the annotation matrix containing information about which cell line contains which Drivermutation
annotation$has_TP53 <- ifelse(rownames(anno) %in% dmTP53$DepMap_ID, TRUE, FALSE)
annotation$has_ARID1A <- ifelse(rownames(anno) %in% dmARID1A$DepMap_ID, TRUE, FALSE)
annotation$has_ATM <- ifelse(rownames(anno) %in% dmATM$DepMap_ID, TRUE, FALSE)
annotation$has_BAI1 <- ifelse(rownames(anno) %in% dmBAI1$DepMap_ID, TRUE, FALSE)
annotation$has_PTPRF <- ifelse(rownames(anno) %in% dmPTPRF$DepMap_ID, TRUE, FALSE)
annotation$has_SYNE1 <- ifelse(rownames(anno) %in% dmSYNE1$DepMap_ID, TRUE, FALSE)
annotation$has_THBS3 <- ifelse(rownames(anno) %in% dmTHBS3$DepMap_ID, TRUE, FALSE)
#to be continued
topVar = apply(kd.prob, 1, var)
tree = kd.prob[topVar > quantile(topVar, probs = 0.75),]
anno <- annotation
rm(topVar)
#to use the function colored_Bars the row and colnames have to be transformed to integer values
colnames(tree) <- c(1:34)
rownames(anno) <- c(1:34)
#the following code calculates the hierachical cluster and plots it
cor.mat = cor(tree, method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)
#to get a good overview we add colored bars under the cluster
#the following code defines colors for our 7 main Drivermutations
cb7 <- ifelse(anno$has_TP53 == "TRUE", "forestgreen", "firebrick")
cb6 <- ifelse(anno$has_ARID1A == "TRUE", "forestgreen", "firebrick")
cb5 <- ifelse(anno$has_ATM == "TRUE", "forestgreen", "firebrick")
cb4 <- ifelse(anno$has_PTPRF == "TRUE", "forestgreen", "firebrick")
cb3 <- ifelse(anno$has_BAI1 == "TRUE", "forestgreen", "firebrick")
cb2 <- ifelse(anno$has_SYNE1 == "TRUE", "forestgreen", "firebrick")
cb1 <- ifelse(anno$has_THBS3 == "TRUE", "forestgreen", "firebrick")
#we have to bind them in one variable
cb <- cbind(`THBS3` = cb1, `SYNE1` = cb2, `BAI1` = cb3, `PTPRF` = cb4, `ATM` = cb5, `ARID1A` = cb6, `TP53` = cb7)
#and add it to the cluster
colored_bars(colors = cb, dend = cor.hc)
View(anno)
annotation$has_TP53 <- ifelse(rownames(annotation) %in% dmTP53$DepMap_ID, TRUE, FALSE)
annotation$has_ARID1A <- ifelse(rownames(annotation) %in% dmARID1A$DepMap_ID, TRUE, FALSE)
annotation$has_ATM <- ifelse(rownames(annotation) %in% dmATM$DepMap_ID, TRUE, FALSE)
annotation$has_BAI1 <- ifelse(rownames(annotation) %in% dmBAI1$DepMap_ID, TRUE, FALSE)
annotation$has_PTPRF <- ifelse(rownames(annotation) %in% dmPTPRF$DepMap_ID, TRUE, FALSE)
annotation$has_SYNE1 <- ifelse(rownames(annotation) %in% dmSYNE1$DepMap_ID, TRUE, FALSE)
annotation$has_THBS3 <- ifelse(rownames(annotation) %in% dmTHBS3$DepMap_ID, TRUE, FALSE)
View(anno)
topVar = apply(kd.prob, 1, var)
tree = kd.prob[topVar > quantile(topVar, probs = 0.75),]
anno <- annotation
rm(topVar)
#to use the function colored_Bars the row and colnames have to be transformed to integer values
colnames(tree) <- c(1:34)
rownames(anno) <- c(1:34)
#the following code calculates the hierachical cluster and plots it
cor.mat = cor(tree, method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)
#to get a good overview we add colored bars under the cluster
#the following code defines colors for our 7 main Drivermutations
cb7 <- ifelse(anno$has_TP53 == "TRUE", "forestgreen", "firebrick")
cb6 <- ifelse(anno$has_ARID1A == "TRUE", "forestgreen", "firebrick")
cb5 <- ifelse(anno$has_ATM == "TRUE", "forestgreen", "firebrick")
cb4 <- ifelse(anno$has_PTPRF == "TRUE", "forestgreen", "firebrick")
cb3 <- ifelse(anno$has_BAI1 == "TRUE", "forestgreen", "firebrick")
cb2 <- ifelse(anno$has_SYNE1 == "TRUE", "forestgreen", "firebrick")
cb1 <- ifelse(anno$has_THBS3 == "TRUE", "forestgreen", "firebrick")
#we have to bind them in one variable
cb <- cbind(`THBS3` = cb1, `SYNE1` = cb2, `BAI1` = cb3, `PTPRF` = cb4, `ATM` = cb5, `ARID1A` = cb6, `TP53` = cb7)
#and add it to the cluster
colored_bars(colors = cb, dend = cor.hc)
View(annotation)
load("~/GitHub/project-01-group-03/OCdata.RDS.RData")
dm <- new_uniq[which(new_uniq$Hugo_Symbol %in% DriverMutation$Var1), ]
#and delete unnecesary columns
dm = dm[, -which(colnames(dm) %in% c("Chromosome", "isDeleterious", "Variant_annotation"))]
#lets check out how many Drivermutations are common in the cell lines
table(dm$DepMap_ID)
#to get acces to the single cell lines we have to create single matrices for every Drivermutation
dmTP53 = dm[which(dm$Hugo_Symbol == "TP53"), ]
dmARID1A = dm[which(dm$Hugo_Symbol == "ARID1A"), ]
dmATM = dm[which(dm$Hugo_Symbol == "ATM"), ]
dmBAI1 = dm[which(dm$Hugo_Symbol == "BAI1"), ]
dmPTPRF = dm[which(dm$Hugo_Symbol == "PTPRF"), ]
dmSYNE1 = dm[which(dm$Hugo_Symbol == "SYNE1"), ]
dmTHBS3 = dm[which(dm$Hugo_Symbol == "THBS3"), ]
#now we add new colums to the annotation matrix containing information about which cell line contains which Drivermutation
annotation$has_TP53 <- ifelse(rownames(annotation) %in% dmTP53$DepMap_ID, TRUE, FALSE)
annotation$has_ARID1A <- ifelse(rownames(annotation) %in% dmARID1A$DepMap_ID, TRUE, FALSE)
annotation$has_ATM <- ifelse(rownames(annotation) %in% dmATM$DepMap_ID, TRUE, FALSE)
annotation$has_BAI1 <- ifelse(rownames(annotation) %in% dmBAI1$DepMap_ID, TRUE, FALSE)
annotation$has_PTPRF <- ifelse(rownames(annotation) %in% dmPTPRF$DepMap_ID, TRUE, FALSE)
annotation$has_SYNE1 <- ifelse(rownames(annotation) %in% dmSYNE1$DepMap_ID, TRUE, FALSE)
annotation$has_THBS3 <- ifelse(rownames(annotation) %in% dmTHBS3$DepMap_ID, TRUE, FALSE)
#to be continued
topVar = apply(kd.prob, 1, var)
tree = kd.prob[topVar > quantile(topVar, probs = 0.75),]
anno <- annotation
rm(topVar)
#to use the function colored_Bars the row and colnames have to be transformed to integer values
colnames(tree) <- c(1:34)
rownames(anno) <- c(1:34)
#the following code calculates the hierachical cluster and plots it
cor.mat = cor(tree, method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)
plot(cor.hc, las = 2, cex.lab = 0.7)
#to get a good overview we add colored bars under the cluster
#the following code defines colors for our 7 main Drivermutations
cb7 <- ifelse(anno$has_TP53 == "TRUE", "forestgreen", "firebrick")
cb6 <- ifelse(anno$has_ARID1A == "TRUE", "forestgreen", "firebrick")
cb5 <- ifelse(anno$has_ATM == "TRUE", "forestgreen", "firebrick")
cb4 <- ifelse(anno$has_PTPRF == "TRUE", "forestgreen", "firebrick")
cb3 <- ifelse(anno$has_BAI1 == "TRUE", "forestgreen", "firebrick")
cb2 <- ifelse(anno$has_SYNE1 == "TRUE", "forestgreen", "firebrick")
cb1 <- ifelse(anno$has_THBS3 == "TRUE", "forestgreen", "firebrick")
#we have to bind them in one variable
cb <- cbind(`THBS3` = cb1, `SYNE1` = cb2, `BAI1` = cb3, `PTPRF` = cb4, `ATM` = cb5, `ARID1A` = cb6, `TP53` = cb7)
#and add it to the cluster
colored_bars(colors = cb, dend = cor.hc)
#to investigate which cell lines contain which drivermutation we create a new data frame containing only the colums about our four Drivermutations
annodm <- annotation[, -which(colnames(anno) %in% c("CCLE_Name", "Subtype.Disease", "has_BAI1", "has_SYNE1", "has_THBS3"))]
#to seperate the cell lines in groups with similar Mutations we give every Drivermutation a specific value: If TP53 is True in the cell line it gets a "1000" , if it isnt ther will be a "0"
annodm$has_TP53 <- ifelse(rownames(anno) %in% dmTP53$DepMap_ID, 1000, 0)
#same here, ARID1A gets a "100" for True and a "0" for FALSE
annodm$has_ARID1A <- ifelse(rownames(anno) %in% dmARID1A$DepMap_ID, 100, 0)
#and the same for the next Mutations
annodm$has_ATM <- ifelse(rownames(anno) %in% dmATM$DepMap_ID, 10, 0)
annodm$has_PTPRF <- ifelse(rownames(anno) %in% dmPTPRF$DepMap_ID, 1, 0)
#we can now sum up these values in a new column
annodm$summe <- apply(annodm, 1, function(x) { sum(x)})
#we picked the most common combinations and gave them different categories by their sums
annodm$kat <- ifelse(annodm$summe == 1000, "TP_only", ifelse(annodm$summe > 1099, "TP+AR", ifelse(annodm$summe == 100, "AR_only", ifelse(annodm$summe == 110, "AR+AT", ifelse(annodm$summe == 101, "AR+PT", ifelse(annodm$summe < 100, "no_TP+no_AR", ifelse(annodm$summe == 0, "nix", "TP+SM")))))))
#we also gave them different colors by using the same function as before
pcb <- ifelse(annodm$summe == 1000, "lightblue", ifelse(annodm$summe > 1099, "purple",  ifelse(annodm$summe == 100, "pink",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red", ifelse(annodm$summe == 11, "green", ifelse(annodm$summe == 10, "grey",ifelse(annodm$summe == 0, "grey","blue"))))))))
#and we added another column to the matrix containing that colors
annodm$col <- pcb
topVar = apply(kd.prob, 1, var) # calculate variance over all rows (genes)
summary(topVar)
kd.prob.topVar = kd.prob[topVar > quantile(topVar, probs = 0.75), ] # new data frame with just the genes whose knockout leads to highly variant cell death events -> perhaps our synthetic lethality interaction partners?
dim(kd.prob.topVar) # show me how many genes we are looking at now
mean.survival.prob <- apply(kd.prob.topVar, 1, mean) # calculate the mean cell survival probability of the remaining genes
summary(mean.survival.prob) # show me the mean survival distribution of the genes whose knockout leads to the most variant cell survival
plot(density(as.matrix(mean.survival.prob))) # plot me the distribution of cell survival probability of most variant survivals
#weiÃŸ noch nicht, wie sinnvoll das alles ist :D mal sehen
#we use the colors defined in step 4 for our co existing muattions
pcb <- cbind(`TP` = pcb)
#keine Ahnung warum ich das machen muss ich frag david noch... aber ohne gehts net
#this function calculates the PCA with the variance calculated bafore
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
#we plot the pca with the different colors for cell lines with similar Driver Mutations
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
#we also add a legend to the plot
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
View(anno)
View(annodm)
#to investigate which cell lines contain which drivermutation we create a new data frame containing only the colums about our four Drivermutations
annodm <- annotation[, -which(colnames(annotation) %in% c("CCLE_Name", "Subtype.Disease", "has_BAI1", "has_SYNE1", "has_THBS3"))]
#to seperate the cell lines in groups with similar Mutations we give every Drivermutation a specific value: If TP53 is True in the cell line it gets a "1000" , if it isnt ther will be a "0"
annodm$has_TP53 <- ifelse(rownames(annotation) %in% dmTP53$DepMap_ID, 1000, 0)
#same here, ARID1A gets a "100" for True and a "0" for FALSE
annodm$has_ARID1A <- ifelse(rownames(annotation) %in% dmARID1A$DepMap_ID, 100, 0)
#and the same for the next Mutations
annodm$has_ATM <- ifelse(rownames(annotation) %in% dmATM$DepMap_ID, 10, 0)
annodm$has_PTPRF <- ifelse(rownames(annotation) %in% dmPTPRF$DepMap_ID, 1, 0)
#we can now sum up these values in a new column
annodm$summe <- apply(annodm, 1, function(x) { sum(x)})
annodm$kat <- ifelse(annodm$summe == 1000, "TP_only", ifelse(annodm$summe > 1099, "TP+AR", ifelse(annodm$summe == 100, "AR_only", ifelse(annodm$summe == 110, "AR+AT", ifelse(annodm$summe == 101, "AR+PT", ifelse(annodm$summe < 100, "no_TP+no_AR", ifelse(annodm$summe == 0, "nix", "TP+SM")))))))
#we also gave them different colors by using the same function as before
pcb <- ifelse(annodm$summe == 1000, "lightblue", ifelse(annodm$summe > 1099, "purple",  ifelse(annodm$summe == 100, "pink",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red", ifelse(annodm$summe == 11, "green", ifelse(annodm$summe == 10, "grey",ifelse(annodm$summe == 0, "grey","blue"))))))))
#and we added another column to the matrix containing that colors
annodm$col <- pcb
#we use the colors defined in step 4 for our co existing muattions
pcb <- cbind(`TP` = pcb)
#keine Ahnung warum ich das machen muss ich frag david noch... aber ohne gehts net
#this function calculates the PCA with the variance calculated bafore
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
#we plot the pca with the different colors for cell lines with similar Driver Mutations
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
#we also add a legend to the plot
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 40, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
legend("topright", pch = 30, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 30, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 1, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 2, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.75)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.50)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.100)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=.99)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=1.99)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=1.5)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= c("lightblue", "blue", "pink", "red", "purple", "grey"), legend = c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"), bty='n', cex=1.3)
colors <- c("blue", "darkblue", "yellow", "orange", "green", "grey")
cat$col <- colors
cat <- as.data.frame(colors)
View(cat)
cat$cat <- c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A"))
cat$cat <- c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A")
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= cat$colors, legend = cat$cat, bty='n', cex=1.3)
View(cat)
pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "green",  ifelse(annodm$summe == 100, "orange",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red",  ifelse(annodm$summe == 10, "grey",ifelse(annodm$summe == 0, "grey","darkblue")))))))
annodm$col <- pcb
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
pcb <- cbind(`TP` = pcb)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
colors <- c("blue", "darkblue", "orange", "red", "green", "grey")
cat <- as.data.frame(colors)
cat$cat <- c("TP53 only","TP53 & sec. Mu", "ARID1A only", "ARID1A & sec. Mu", "TP53 & ARID1A", "no TP53 & no ARID1A")
legend("topright", pch = 20, col= cat$colors, legend = cat$cat, bty='n', cex=1.3)
unique(annodm$col)
unique(annodm$kat)
annodm$kat <- ifelse(annodm$summe == 1000, "TP53 only", ifelse(annodm$summe > 1099, "TP53 & ARID1A", ifelse(annodm$summe == 100, "ARID1A only", ifelse(annodm$summe == 110, "ARID1A & sec. Mu", ifelse(annodm$summe == 101, "ARID1A & sec. Mu", ifelse(annodm$summe < 100, "no TP53 & no ARID1A", ifelse(annodm$summe == 0, "no TP53 & no ARID1A", "TP53 & sec. Mu")))))))
View(annodm)
pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "green",  ifelse(annodm$summe == 100, "orange",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red",  ifelse(annodm$summe == 10, "grey",ifelse(annodm$summe == 0, "grey","darkblue")))))))
#and we added another column to the matrix containing that colors
annodm$col <- pcb
View(annodm)
pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "green",  ifelse(annodm$summe == 100, "orange",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red",  ifelse(annodm$summe < 100, "grey",ifelse(annodm$summe == 0, "grey","darkblue")))))))
#and we added another column to the matrix containing that colors
annodm$col <- pcb
View(annodm)
rm(cat)
annodm$kat <- ifelse(annodm$summe == 1000, "TP53 only", ifelse(annodm$summe > 1099, "TP53 & ARID1A", ifelse(annodm$summe == 100, "ARID1A only", ifelse(annodm$summe == 110, "ARID1A & sec. Mu", ifelse(annodm$summe == 101, "ARID1A & sec. Mu", ifelse(annodm$summe < 100, "no TP53 & no ARID1A", ifelse(annodm$summe == 0, "no TP53 & no ARID1A", "TP53 & sec. Mu")))))))
#we also gave them different colors by using the same function as before
pcb <- ifelse(annodm$summe == 1000, "blue", ifelse(annodm$summe > 1099, "green",  ifelse(annodm$summe == 100, "orange",  ifelse(annodm$summe == 110, "red", ifelse(annodm$summe == 101, "red",  ifelse(annodm$summe < 100, "grey",ifelse(annodm$summe == 0, "grey","darkblue")))))))
#and we added another column to the matrix containing that colors
annodm$col <- pcb
#we use the colors defined in step 4 for our co existing muattions
pcb <- cbind(`TP` = pcb)
#keine Ahnung warum ich das machen muss ich frag david noch... aber ohne gehts net
#this function calculates the PCA with the variance calculated bafore
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
#we plot the pca with the different colors for cell lines with similar Driver Mutations
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
cat <- as.data.frame(unique(annodm$col))
cat$cat <- unique(annodm$kat)
legend("topright", pch = 20, col= cat$colors, legend = cat$cat, bty='n', cex=1.3)
View(cat)
rm(cat)
cat$col <- as.data.frame(unique(annodm$col))
cat$cat <- unique(annodm$kat)
rm(colors, cat)
colors <- unique(annodm$col)
cat$col <- as.data.frame(colors)
cat$cat <- unique(annodm$kat)
colors
colors <- unique(annodm$col)
cat <- as.data.frame(colors)
cat$cat <- unique(annodm$kat)
View(cat)
legend("topright", pch = 20, col= cat$colors, legend = cat$cat, bty='n', cex=1.3)
rm(colors, cat)
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
cat <- as.data.frame(unique(annodm$col))
cat$cat <- unique(annodm$kat)
legend("topright", pch = 20, col= cat$colors, legend = cat$cat, bty='n', cex=1.3)
rm(colors, cat)
colors <- unique(annodm$col)
cat <- as.data.frame(colors)
cat$cat <- unique(annodm$kat)
legend("topright", pch = 20, col= cat$colors, legend = cat$cat, bty='n', cex=1.3)
View(annodm)
topVar = apply(kd.ceres, 1, var) # calculate variance over all rows (genes)
summary(topVar)
kd.prob.topVar = kd.ceres[topVar > quantile(topVar, probs = 0.75),
]
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
#we plot the pca with the different colors for cell lines with similar Driver Mutations
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
legend("topright", pch = 20, col= cat$colors, legend = cat$cat, bty='n', cex=1.3)
topVar = apply(kd.ceres, 1, var) # calculate variance over all rows (genes)
summary(topVar)
kd.prob.topVar = kd.ceres[topVar > quantile(topVar, probs = 0.9), ]
pca = prcomp(kd.prob.topVar, center = F, scale. = F)
#we plot the pca with the different colors for cell lines with similar Driver Mutations
plot(pca$rotation[, 1], pca$rotation[, 2], col = pcb[, 1], pch = 19, xlab = "PC1",      ylab = "PC2")
plot(annodm, las = 2, cex.lab = 0.7)
plot(annodm$has_TP53, las = 2, cex.lab = 0.7)
plot(annodm$summe, las = 2, cex.lab = 0.7)
load("~/GitHub/project-01-group-03/OCdata.RDS.RData")
